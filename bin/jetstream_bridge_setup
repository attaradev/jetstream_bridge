#!/usr/bin/env ruby
# frozen_string_literal: true

require 'bundler/setup'
require 'jetstream_bridge'
require 'nats/io/client'
require 'optparse'

only = nil

parser = OptionParser.new do |o|
  o.banner = 'Usage: jetstream_bridge_setup [--only stream|dlq|consumer]'
  o.on('--only WHAT', 'Limit setup to one: stream, dlq, consumer') { |v| only = v }
  o.on('-h', '--help', 'Show this help') do
    puts o
    exit 0
  end
end

begin
  parser.parse!
rescue OptionParser::ParseError => e
  warn e.message
  warn parser
  exit 64 # EX_USAGE
end

# Convert "30s", 30 (sec), 5000 (ms), 1.5, 1.5s into **milliseconds** (Integer)
def to_millis(val)
  case val
  when Integer
    # Heuristic: treat small integers as seconds, large as ms.
    val >= 1_000 ? val : val * 1_000
  when Float
    (val * 1_000).round
  when String
    s = val.strip
    return s.to_i * 1_000 if s =~ /\A\d+\z/ # seconds as integer

    if s =~ /\A(\d+(?:\.\d+)?)\s*(ms|s|m|h)\z/i
      qty  = Regexp.last_match(1).to_f
      unit = Regexp.last_match(2)&.downcase
      mult = { 'ms' => 1, 's' => 1_000, 'm' => 60_000, 'h' => 3_600_000 }[unit]
      return (qty * mult).round
    end
    raise ArgumentError, "invalid duration: #{val.inspect}"
  else
    return (val.to_f * 1_000).round if val.respond_to?(:to_f) # e.g., ActiveSupport::Duration

    raise ArgumentError, "invalid duration type: #{val.class}"
  end
end

def ensure_stream(js, name, subjects)
  js.stream_info(name)
  puts "Stream #{name} exists."
rescue NATS::JetStream::Error
  js.add_stream(name: name, subjects: subjects, storage: 'file', retention: 'limits')
  puts "Stream #{name} created."
end

def ensure_consumer(js, stream, durable, filter, cfg)
  js.consumer_info(stream, durable)
  puts "Consumer #{durable} exists."
rescue NATS::JetStream::Error
  js.add_consumer(
    stream,
    durable_name: durable,
    filter_subject: filter,
    ack_policy: 'explicit',
    max_deliver: cfg[:max_deliver],
    ack_wait: cfg[:ack_wait_ms], # milliseconds
    backoff: cfg[:backoff_ms] # array of milliseconds
  )
  puts "Consumer #{durable} created."
end

def subject_covered_by?(patterns, subject)
  patterns.any? do |pat|
    pt = pat.split('.')
    st = subject.split('.')
    i = 0
    while i < pt.size && i < st.size
      case pt[i]
      when '>' then return true
      when '*' # matches any single token
      else break if pt[i] != st[i]
      end
      i += 1
    end
    (i == pt.size && i == st.size) || (pt.last == '>')
  end
end

def ensure_dlq_on_main_stream(js, stream_name, dlq_subject)
  info     = js.stream_info(stream_name)
  subjects = Array(info.config.subjects || [])
  if subject_covered_by?(subjects, dlq_subject)
    puts "DLQ subject #{dlq_subject} already covered by #{stream_name}"
    return
  end
  new_subjects = (subjects + [dlq_subject]).uniq
  js.update_stream(name: stream_name, subjects: new_subjects)
  puts "Updated #{stream_name} subjects to include #{dlq_subject}"
end

def ensure_consumers_from_config(js, stream_name, env, cfg)
  dest = JetstreamBridge.config.destination_app.to_s.strip
  if dest.empty?
    puts 'No destination_app set in config; skipping consumer creation.'
    return
  end
  ensure_consumer(js, stream_name, "#{env}-#{dest}-events", "#{env}.data.sync.#{dest}.>", cfg)
end

nc = nil
begin
  urls = (JetstreamBridge.config.nats_urls || 'nats://127.0.0.1:4222')
         .to_s.split(',').map(&:strip).reject(&:empty?)
  raise 'No NATS URLs provided' if urls.empty?

  nc = NATS::IO::Client.new
  nc.connect(servers: urls)
  js = nc.jetstream

  env         = (JetstreamBridge.config.env || 'development').to_s
  stream_name = (JetstreamBridge.config.stream_name || "#{env}-data-sync").to_s
  dlq_subject = "#{env}.data.sync.dlq"

  cfg = {
    max_deliver: JetstreamBridge.config.max_deliver,
    ack_wait_ms: to_millis(JetstreamBridge.config.ack_wait),
    backoff_ms: Array(JetstreamBridge.config.backoff).map { |d| to_millis(d) }
  }

  # 1) Ensure main stream
  ensure_stream(js, stream_name, ["#{env}.data.sync.>"])  if only.nil? || only == 'stream'

  # 2) Ensure DLQ subject on the same stream
  ensure_dlq_on_main_stream(js, stream_name, dlq_subject) if only.nil? || only == 'dlq'

  # 3) Ensure consumer(s) from config (no hw/pwas defaults)
  ensure_consumers_from_config(js, stream_name, env, cfg) if only.nil? || only == 'consumer'

  puts 'âœ… Setup complete.'
  exit 0
rescue Interrupt
  puts "\nAborted."
  exit 130
rescue StandardError => e
  warn "[jetstream_bridge_setup] #{e.class}: #{e.message}"
  exit 1
ensure
  nc&.close
end
